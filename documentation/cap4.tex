%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 4: Diseño y resolución del trabajo realizado
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Diseño y resolución del trabajo realizado}
\label{diseno}

Después de estudiar cual es la situación actual de la enseñanza de la programación a un nivel global y los diferentes proyectos que promueven el \emph{pensamiento computacional}, en este capítulo se analizarán cuales son las necesidades del proyecto Robode y como se han resuelto.

Como ya se ha mencionado anteriormente, se creará un simulador de un robot, al que hemos denominado \emph{Robode}, y se integrará en la plataforma Descubre la programación. Robode  estará dentro de un mundo del que podrá moverse con libertad y con el que podrá interactuar. El robot tendrá dos ruedas que se mueven independientemente (con un motor para cada una de ellas) y dispondrá de sensores que informarán de posibles colisiones con obstáculos. También, el robot tendrá la capacidad de detectar color en el suelo debajo del mismo. Ésta capacidad se usará para detectar lineas pintadas de negro en el suelo.

Adicionalmente, el robot y el mundo en el que este se encuentra será dibujado en un elemento \emph{canvas} de HTML5, al igual que ocurre en la plataforma Descubre. El \emph{canvas} es un elemento de HTML5 que establece un \emph{lienzo} en el que se pueden dibujar gráficos\footnote{Los gráficos pueden ser en 2 o 3 dimensiones, pero en el simulador que se desarrollará solo se hará uso de gráficos 2D.}. De igual modo, HTML5 proporciona muchas funciones para dibujar en el \emph{canvas} de manera relativamente sencilla.


Como se puede ver, Robode es la unión de varios de los proyectos que se han analizado en el capítulo \ref{estado-arte}. Por una parte, la idea principal de crear un simulador es igual a la que se ha realizado en Robomind (el cual se analiza en la sección \ref{sec:robomind}) pero simulando un robot en un mundo continuo y con características similares a las de Moway (analizado en la sección \ref{sec:moway}). Por último, se ejecutará en un entorno web, como bien puede ser el ejemplo de las herramientas que proporcionan CodeHS (sección \ref{sec:CodeHS}) y Code.org (sección \ref{sec:Code.org}). 


En las secciones siguientes se va a estudiar como se ha diseñado y creado Robode, que características tiene y cual ha sido la implementación exacta llevada a cabo.




\section{Integración en Descubre}
\label{sec:integracion-descubre}

\subsection{Modificación del lenguaje iJava}
\label{sec:modificacion-ijava}







\section{Motor físico}
\label{sec:motor-fisico}

El simulador representará un mundo con un robot y una serie de obstáculos que interfieren entre ellos. Los obstáculos podrán colisionar entre ellos o con el robot. También será necesario simular lineas en el suelo y la detección de las mismas. Todo ello con un paso del tiempo realista. Para ello, es necesario utilizar un motor físico que simule la creación de cuerpos en el mundo, su movimiento por el mismo y el contacto entre ellos, generando una reacción similar a la producida en el mundo real.

Para la creación del mundo y de las físicas que gestionan las colisiones y la interacción entre todos los elementos del simulador se han estudiado dos motores físicos: PhysicsJS\footnote{Página oficial de la librería PhysicsJS (\url{http://wellcaffeinated.net/PhysicsJS}).} y Box2D\footnote{El manual de uso de Box2D se puede encontrar en \cite{box2d-manual}. La documentación del proyecto se puede encontrar en (\url{http://www.box2dflash.org/docs/2.1a/reference/}).} \cite{box2d}. Dos librerías muy versátiles y de software libre que trabajan sobre entornos web.

PhysicsJS  es una librería escrita enteramente en Javascript por Jasper Palfree que aún está en fase beta. Por otra parte, Box2D es una famosa librería implementada originalmente para Flash\footnote{Página oficial de la librería Box2D para Flash (\url{http://www.box2dflash.org}).} con una gran comunidad de programadores utilizando dicha librería, lo cual siempre es de ayuda para resolver dudas y solucionar problemas. 

Box2D ha sido portada a Javascript dos veces. Una de ellas por Yayushi Ando y se llama Box2Djs\footnote{Página oficial de Box2Djs (\url{http://box2d-js.sourceforge.net}).} pero el proyecto no ha sido continuado y está desactualizado. El otro intento de llevar Box2D a Javascript ha culminado en Box2Dweb\footnote{El repositorio de Box2Dweb está alojado en GitHub (\url{https://github.com/hecht-software/box2dweb}).}. Como se puede leer en \cite[capítulo 13]{box2d-manual}, Box2D usa una serie de aproximaciones para representar las colisiones de manera eficiente. Principalmente, son dos las limitaciones que podría afectar al simulador del robot: (a) existe un desliz de aproximadamente 0.5 cm entre la forma que tiene un cuerpo y la colisión del mismo y (b) Box2D no maneja correctamente los cuerpos cóncavos. 

Al final, se ha establecido que la librería a utilizar será Box2Dweb. En cuanto a las limitaciones que puedan afectar a Robode, estas no son un gran problema a la solución del simulador puesto que: el desliz producido en limitación (a) es muy pequeño y en el caso del simulador, impercetible. Con respecto a la limitación (b), en el caso de que se quiera construir cuerpos cóncavos, se puede solucionar creando más de un cuerpo convexo que cree una forma \emph{global} cóncava.

Una vez que se ha aclarado que la librería utilizada es \texttt{Box2Dweb}, por simplicidad, a partir de ahora nos referiremos a ésta simplemente como \texttt{Box2D}.

\subsection{Definición del Mundo}
\label{sec:definicion-mundo}

En \texttt{Box2D} existen una serie de objetos que representan al mundo y los diferentes elementos que lo componen.  Estos son: el Mundo (World), los Cuerpos (Bodies), los Accesorios (Fixtures) y las Articulaciones o elementos constrictores (Joints).

El núcleo de Box2D es el objeto \emph{World}, el cual define los parámetros básicos que regirán la simulación más tarde, como puede ser el ratio de actualización o la gravedad. También crea y almacena el resto de objetos de Box2D, como los \emph{Bodies}, las \emph{Fixtures} y los \emph{Joints}, entre otros.

Para la creación de nuestro mundo, hemos decidido que tendrá una vista \emph{top-down}, es decir, una vista del mundo desde arriba, desde el cielo. De esta manera se consigue una vista superior de todo el circuito simplificando la comprensión del movimiento del robot sobre el circuito.

Una de las características más importantes de \texttt{Box2D} es la posibilidad de dotar a la aplicación que se está creando de un efecto gravitatorio de manera nativa al motor. Lo normal sería establecer éste valor con un vector de dirección hacia el suelo (hacia la parte baja de la pantalla) con la fuerza que se quiera simular. Esto provocaría que los cuerpos del mundo estuvieran constantemente sometidos a una fuerza que los mueve en dirección a ese vector, normalmente hacia el suelo.  

En el caso de Robode, al tener una vista superior del circuito, establecer una gravedad provocaría que el robot y el resto de cuerpos del circuito se movieran de forma anómala. Por esto, es necesario crear un mundo sin gravedad. En el listado del código \ref{code:world-gravedad} podemos ver como se ha establecido la gravedad del mundo a un vector con valor 0 en ambos ejes de coordenadas. 

\begin{lstlisting}[language={Javascript},label={code:world-gravedad}, caption={Definición del objeto \texttt{World} en Box2D con gravedad 0 y permitiendo que los cuerpos sean capaces de dormir.}]
Simulator.World = new b2World(
	new b2Vec2(0, 0), //gravity
	true //allow sleep
);
\end{lstlisting}

Otra característica importante en Box2D y que tiene un gran impacto en el rendimiento de la simulación es que los cuerpos puedan \emph{dormir}. Un cuerpo \emph{dormirá} cuando éste esté inactivo, es decir, cuando no esté siendo sometido a ninguna fuerza o sobre el se aplican fuerzas, pero éstas no son capaces de alterar su estado (posición, ángulo de giro, etc)\footnote{Esto ocurre generalmente cuando un objeto está sobre una superficie cuya forma y la del cuerpo hace que éste se mantenga quieto. Un ejemplo de esto puede ser un cuadrado sobre una superficie plana y horizontal con una gravedad hacia el suelo.}. En la línea 3 del listado de códigos \ref{code:world-gravedad} se puede ver como se ha establecido que los cuerpos del mundo sean capaces de dormir. Así, se consigue que el motor no simule los cuerpos que estén inactivos, mejorando el rendimiento de la aplicación.

Por último, queda definir el \emph{paso del tiempo} en Box2D. Para ello, es necesario ejecutar la función \texttt{Simulator.World.Step()} cada vez que queramos que se ejecute un \emph{paso} en nuestro mundo (esto es equivalente a un \emph{tic} de reloj). Esta función ordenará al motor que aplique todas las fuerzas necesarias sobre los cuerpos del mundo (gravedad, colisiones, deslizamientos, etc). Obviamente, es en este momento cuando se ejecutará la detección de colisiones por parte del motor de físicas. Justo después de ejecutar un paso se deben eliminar las fuerzas que afectan a los objetos para que se produzca un movimiento y efecto natural de las distintas fuerzas en los cuerpos. Esto se consigue con la función \texttt{Simulator.World.ClearForces()}.

En la figura \ref{fig:step-box2d} se muestra una representación de lo que ocurre en el motor de Box2D cada vez que se ejecuta un \emph{step}. En el código  \ref{code:world-step} se puede ver con más detalle las funciones básicas que se deben ejecutar para que se produzca una actualización del mundo en Box2D.

\begin{figure}[!ht]
	\begin{centering}
		\includegraphics[width=0.5\textwidth]{images/step-box2d.png}
			\caption{Representación de lo que ocurre cada vez que se realiza la llamada a la función \texttt{Step()} en Box2D. Obtenido de \cite{box2d}.}
				\label{fig:step-box2d}
	\end{centering}
\end{figure}

\begin{lstlisting}[language={Javascript},label={code:world-step}, caption={Actualización del mundo en \texttt{Box2D}.}]
// (...)
Simulator.World.Step(
	1 / 60, //frame-rate
	10, //velocity iterations
	10 //position iterations
);

Simulator.World.ClearForces();

// (...)
\end{lstlisting}

En el apéndice \ref{anexo:creacion-elementos-box2d} se explica en detalle las características básicas y más importantes de los objetos \texttt{Body}, \texttt{Fixture} y \texttt{Joint} de Box2D.


\subsection{Construcción del robot}
\label{sec:contruccion-robot}

Para la creación del robot, un referente importante ha sido el robot de Moway. La forma y disposición de los sensores es similar a la simulada en Robode. Otro objetivo a cumplir era el de crear una simulación que imitara un comportamiento natural del robot a la hora de moverse, de chocar o de detenerse. Por tanto, se han establecido diferentes propiedades en los cuerpos para cumplir este objetivo.

Anteriormente ya se ha mencionado que el robot tendrá 2 ruedas, 2 sensores que detectarán líneas y otros 4 que detectaran colisiones. Todos estos elementos del robot están modelados en cuerpos separados. No obstante, es necesario que se mantengan unidos y se muevan a la vez.

En la figura \ref{fig:robot-skel} se puede ver un esqueleto del Robode.

\begin{figure}[!ht]
	\begin{centering}
		\includegraphics[width=0.5\textwidth]{images/robot-skel.png}
			\caption{Esqueleto del robot que muestra los diferentes \emph{bodies} y \emph{joints} que lo forman.}
				\label{fig:robot-skel}
	\end{centering}
\end{figure}

En las siguientes secciones se explicará más en detalle como se han creado cada una de las partes del robot.
 
\subsubsection*{Cuerpo principal}
\label{sec:cuerpo-principal}

El cuerpo principal está modelado como un rectángulo. Éste será más largo que ancho y tendrá el resto de cuerpos (sensores y ruedas) \emph{atados} a él con joints. El cuerpo principal de Robode será dinámico, así como los sensores y ruedas.

La forma se ha creado creando una fixture con forma poligonal. Se ha utilizado la función \texttt{SetAsBox()} que permite definir el ancho y alto del polígono, creándolo con forma rectangular. El ancho del robot será de 6 píxeles mientras que su largo medirá 10 píxeles.

En el listado de código \ref{code:creacion-cuerpo-principal} se puede ver el código que construye el cuerpo principal de Robode.

\begin{lstlisting}[language={Javascript},label={code:creacion-cuerpo-principal}, caption={Creación del cuerpo principal del robot utilizando la librería Box2dweb.}]
// Body definition
var bodyDef = new b2BodyDef(); 
bodyDef.type = b2Body.b2_dynamicBody;
bodyDef.position.Set(posX, posY);
bodyDef.linearDamping = 8;
bodyDef.angularDamping = 8;

// Fixture definition
var fixDef = new b2FixtureDef(); 
fixDef.density = 40;
fixDef.friction = 1;
fixDef.restitution = 0;
// Polygon Shape as a box
fixDef.shape = new b2PolygonShape(); 
fixDef.shape.SetAsBox(width, height);

// Create BODY robot
var robot = Simulator.World.CreateBody(bodyDef);
robot.setName("robot");

// Add fixture to body
robot.CreateFixture(fixDef);
\end{lstlisting}


\subsubsection*{Ruedas}

Las ruedas de Robode se simularan con dos polígonos con forma rectangular  (método \texttt{SetAsBox()} de la clase \texttt{b2PolygonShape}). Su posición está retrasada con respecto al centro del cuerpo principal y su ancho es de 2 píxeles mientras que su alto mide 4 píxeles. En el listado de código \ref{code:creation-wheel} se puede ver como se han construido las ruedas. Como se puede ver, se ha mantenido los valores de densidad, fricción y restitución del cuerpo principal, reduciendo así la posibilidad de comportamientos anómalos en colisiones.

\begin{lstlisting}[language={Javascript},label={code:creation-wheel}, caption={Función que crea las ruedas de Robode.}]
function createWheel(x, y) {

	var bodyDef = new b2BodyDef();
	bodyDef.type = b2Body.b2_dynamicBody;
	bodyDef.position.Set(x, y);
	
	var fixDef = new b2FixtureDef();
	fixDef.density = 40;
	fixDef.friction = 1;
	fixDef.restitution = 0;
	fixDef.isSensor = false;

	fixDef.shape = new b2PolygonShape();
	fixDef.shape.SetAsBox(0.2, 0.4);
	
	var wheelBody = Simulator.World.CreateBody(bodyDef);
	wheelBody.setName("wheel");
	wheelBody.CreateFixture(fixDef);
	return wheelBody;
}
\end{lstlisting}

Además, se creará un joint que mantendrá unidas las ruedas con el cuerpo principal de Robode. En el listado de código  \ref{code:wheel-joint} se puede ver la creación de un del joint que une el coche con la rueda.

\begin{lstlisting}[language={Javascript},label={code:wheel-joint}, caption={Función que crea el joint que une la rueda al coche.}]
function addWheelJoint(mybody, mywheel) {

	var revoluteJointDef = new b2RevoluteJointDef();
	revoluteJointDef.Initialize(mybody, mywheel, mywheel.GetWorldCenter());

	revoluteJointDef.enableMotor = true;
	revoluteJointDef.motorSpeed = 0;
	revoluteJointDef.maxMotorTorque = Number.MAX_SAFE_INTEGER;
	revoluteJointDef.enableLimit = true;

	return Simulator.World.CreateJoint(revoluteJointDef);
}
\end{lstlisting}

La función \texttt{Initialize()} recibe como parámetros los dos cuerpos que van a ser unidos por el joint y el punto en el que se realizará el ancla (para eso se utilizará la función \texttt{GetWorldCenter()} de la clase \texttt{Body} para obtener el punto del mundo en el que se encuentra un cuerpo).

Se activará la propiedad de motor en las ruedas y se le dará un valor inicial de 0. También se establecerá el valor máximo de torsión del joint para evitar que ante una fuerza de giro muy grande, el joint se mueva de su sitio. Por último, se activará un límite para que las ruedas no se muevan de su sitio ya que es esta propiedad la que define si el ancla será fija o permitirá movimiento con respecto a la separación de los dos cuerpos.

El movimiento del robot se simulará con el movimiento que se producirá en las ruedas. Este proceso se explicará en la sección \ref{moviendo-robode}.

\subsubsection*{Sensores}

Los sensores de colisión tendrán forma de triángulo y los sensores que detectan lineas forma de círculo. Más adelante se describirá como se les ha otorgado la forma a cada uno del sensor. Por otra parte, todos los sensores serán cuerpos estáticos.

Box2D provee de manera nativa que los cuerpos (en concreto, la \emph{fixture} que contiene) se definan como un \emph{sensor} en el motor físico. Esto otorga una serie de características que hacen que los sensores de Robode puedan percibir cuerpos con los que colisionan. 

Para definir un cuerpo en Box2D como sensor, se tendrá que establecer la propiedad \texttt{isSensor} a \texttt{true} cuando se construya la \emph{fixture} del cuerpo que lo contendrá. En el listado del código \ref{code:creation-sensor} se puede ver como se crean los sensores. La forma que se les ha otorgado a los sensores se explicará en la sección posterior posterior.

\begin{lstlisting}[language={Javascript},label={code:creation-sensor}, caption={Función que construye un sensor de Robode.}]
function Sensor(points, name, bodyAttached) {

    //(...)

    //create our sensor
    var bodyDef = new Simulator.Env.b2BodyDef();
    bodyDef.type = Simulator.Env.b2Body.b2_dynamicBody;
    bodyDef.position.Set(positionIni.x, positionIni.y);
    bodyDef.setName(this.name);
    this.body = Simulator.World.CreateBody(bodyDef);

    var fixDef = new Simulator.Env.b2FixtureDef();
    fixDef.isSensor = true;

    // define the shape
    // points variable contains the point's shape
	if (points.length == 1) {
		// just 1 point -> line sensor
		fixDef.shape = new Simulator.Env.b2CircleShape(0.2);
	} else {
		// collision sensor
		fixDef.shape = new Simulator.Env.b2PolygonShape();
		var vPoints = [];
		points.forEach(function(elem, index, array) {
			vPoints[index] = new Simulator.Env.b2Vec2(elem.x, elem.y);
		});
		fixDef.shape.SetAsArray(vPoints, vPoints.length);
	}

    this.body.CreateFixture(fixDef);

    //(...)
}
\end{lstlisting}

En cuanto a la unión de los sensores al cuerpo principal, se vuelven a usar joints de tipo \texttt{Revolute} para mantenerlos a la misma distancia, al igual que cuando se crearon las ruedas en la sección anterior. La diferencia aquí radica en que no activaremos un motor para los sensores y que desactivaremos la colisión que se crea con el cuerpo, permitiendo que \emph{convivan} en el mismo espacio los sensores y los cuerpos.

Otra modificación con respecto al joint de las ruedas es que solo en los sensores de colisión, la propiedad \texttt{enableLimit} debe ser establecida a \texttt{false}. Si no se hiciera esto, el joint de los sensores de colisión bloquearía el movimiento del joint de las ruedas, impidiendo su movimiento y el coche no se movería.

Una vez se ha visto como se crean los sensores, se ve que hay muchas propiedades que afectan a la gestión de colisiones. Esto se verá más en profundidad en las secciones correspondientes a cada tipo de sensor.

\subsubsection*{Dando forma a los sensores}

Los 4 sensores de colisión tendrán forma de triángulo y estarán dispuestos de forma que sobresalgan del cuerpo principal con la base del triángulo hacía el exterior, para así poder detectar una colisión antes de que ocurra. Las posiciones de cada uno de los 4 sensores se han descrito con las posiciones cardinales: noroeste, sureste, noreste y sureste. De esta manera, el robot tendrá 2 sensores que detectan colisiones en la parte delantera y otros dos en la trasera. 

Los 2 sensores que detectan líneas tendrán forma de círculo simulando dos cámaras que miran hacia abajo, igual que ocurre en el robot Moway. Para dotar de forma a los sensores que detectan líneas, se puede utilizar la clase \texttt{b2CircleShape} y con un radio de 2 píxeles, se asigna la forma al \emph{fixture} correspondiente.

No obstante, la forma de los sensores de colisión, al ser triangular, requiere que se definan los vértices del polígono previamente.  Para realizar esto, utilizaremos la función \texttt{fixDef.shape.SetAsArray()}\footnote{Hay que tener en cuenta que, como ya se ha mencionado en la sección \ref{sec:motor-fisico}, las formas cóncavas no son soportadas por Box2D.} que recibe como parámetro los vértices del polígono a crear y el número de vértices del mismo. Obviamente, los vértices tendrán que formar un triángulo con la base hacia el exterior de Robode.

Lo último que hay que saber al respecto es que los puntos de los vértices tienen que pasarse a la función \texttt{fixDef.shape.SetAsArray()} con respecto al punto origen del cuerpo. En el código \ref{code:vertices-sensorNE} se muestran los puntos de los vértices del sensor en la posición noreste. El resto de sensores tienen la misma longitud pero solo cambia el eje de coordenadas en el que se mueve.

\begin{lstlisting}[language={Javascript},label={code:vertices-sensorNE}, caption={Vértices que forman el triángulo del sensor noreste de Robode.}]
var pointsTR = [
	{
	    x: 0.1,
	    y: -0.1
	}, {
	    x: 0.5,
	    y: -1.6
	}, {
	    x: 1.5,
	    y: -0.8
	}
];
\end{lstlisting}



\subsection{Moviendo a Robode}
\label{moviendo-robode}


El movimiento de Robode está basado en el movimiento de las ruedas. Al igual que ocurre en un coche, son las ruedas de Robode las que tiran del resto. Por tanto, serán las ruedas las que realicen la fuerza para mover al resto del cuerpo. Además, la fuerza que ejerza cada rueda puede ser diferente. 

Para mover las ruedas, hay que aplicar una fuerza a la rueda con respecto al vector que apunta en dirección frontal a la propia rueda. Esto se hace utilizando la función \texttt{ApplyForce()} que recibe como parámetro el vector con la fuerza a realizar y el punto desde el que se realiza. El punto que se usará para aplicar la fuerza será el centro de la propia rueda. Una fuerza con valor positivo hará que el robot se mueva hacia delante. Mientras que una fuera negativa hará que este se mueva hacia atrás.

La fuerza que se aplicará se mide en Newtons y la potencia máxima y mínima será de 4K Newtons y -4K Newtons, respectivamente. Por defecto, la velocidad aplicada al motor se multiplicará por 100, siempre y cuando no se mantenga en los máximos y mínimos ya mencionados.

De esta manera se consigue que la rueda ejerza una fuerza hacia delante (o atrás) y el robot se desplace. Pero esto ocasionará tres problemas: 

\begin{enumerate}
	\item La velocidad angular de las ruedas cambiará y será diferente a la del robot.
	\item Ocurrirá lo mismo que en el punto anterior, pero esta vez con los sensores que detectan colisiones.
	\item Se creará una velocidad lateral (u ortogonal) que hará que el movimiento del robot no sea recto.
\end{enumerate} 

Los dos primeros problemas se resuelven fácilmente igualando la velocidad angular del robot y las ruedas o sensores con la función \texttt{SetAngularVelocity()} de la clase \texttt{b2Body}. De esta manera se consigue que las ruedas y el robot miren siempre en la misma dirección. Además, en el caso de los sensores, también será necesario ajustar el ángulo de giro de los mismos para forzar a que se mantengan en la misma posición con respecto al robot.

Para eliminar la velocidad lateral que se produce al mover el robot, basta con aplicar una velocidad lineal que contrarreste esta fuerza, con el método \texttt{SetLinearVelocity()}. 

Ahora ya se tiene un robot desplazándose por el mundo. Para conseguir que sea de manera realista, se dotará a las ruedas de una fricción fuerte (valor de 1) y al cuerpo principal un valor de deslizamiento lineal y angular de 8 (propiedades \texttt{linearDamping} y \texttt{angularDamping} de \texttt{b2Body}).{\color{red} La forma de establecer estos valores ha sido sobretodo experimental. De esta forma se conseguía asegurar una sensación realista basada en la propia experiencia.}


\subsection{Detectando colisiones}
\label{detectando-colisiones}

La clase \texttt{b2Contact} de Box2D representa el contacto entre dos cuerpos. Esta contiene los dos cuerpos que se están \emph{tocando} y otra información de interés. Box2D proporciona la clase \texttt{b2ContactListener} que permite la redefinición de 4 funciones clave en la gestión de colisiones. Estas son:

\begin{itemize}
	\item Función \texttt{PreSolve()}, que se ejecutará antes de que se produzca por parte del motor de Box2D la solución de la colisión. Es útil para realizar cálculos previos al contacto. Útil también para anular un contacto y que la colisión no se produzca, por ejemplo.
	\item Función \texttt{PostSolve()}, similar a la anterior pero se ejecutará justo después de que la gestión de la colisión haya acabado.
	\item Función \texttt{BeginContact()} que permite controlar cuando un contacto empieza, es decir, cuando un cuerpo colisiona con otro. 
	\item Función \texttt{EndContact()} que se ejecutará cuando un contacto termine, es decir, cuando un cuerpo deje de \texttt{tocar} a otro.
\end{itemize}

Es importante que estas funciones estén lo más optimizadas posible puesto que se ejecutarán cada vez que se produzca un contacto entre dos cuerpos. En el caso del simulador, solo necesitaremos redefinir las funciones \texttt{BeginContact()} y  \texttt{EndContact}. Estas recibirán como parámetro un objeto \texttt{b2Contact} para poder obtener información del contacto que se está produciendo.

En el caso de Robode, puesto que se están simulando sensores muy simples que no distinguen entre detectar uno o más cuerpos, las funciones \texttt{BeginContact()} y \texttt{EndContact} simplemente contarán el número de cuerpos que está sintiendo ese sensor. Por tanto, al comenzar un contacto unicamente se notificará dicha colisión si el sensor no estaba sintiendo nada previamente. De igual manera, cuando un contacto acaba, solo se notificará si el número de cuerpos sentidos por el sensor es 1 (que va a cambiar al 0).

En el listado de código \ref{code:begin-contact} se muestra a modo ilustrativo la función \texttt{BeginContact()}. La función \texttt{EndContact()} sería similar pero decrementando el contador de colisiones.


\begin{lstlisting}[language={Javascript},label={code:begin-contact}, caption={Función \texttt{BeginContact()} definida para los sensores.}]
contactListener.BeginContact = function(contact) {

	if (!running) return;

	var isSensorA = contact.GetFixtureA().IsSensor();
	var isSensorB = contact.GetFixtureB().IsSensor();

	if (isSensorA != isSensorB) { // a XOR b: is any fixture a sensor?
		//find who is the sensor and who the body
		var bodySensed, bodySensor;

		if (isSensorA) {
			bodySensor = contact.GetFixtureA();
			bodySensed = contact.GetFixtureB();
		} else {
			bodySensor = contact.GetFixtureB();
			bodySensed = contact.GetFixtureA();
		}

		// if it's a robot part, do nothing
		if (isRobotPart(bodySensed.getBodyName(), robotparts))
			return;

		/*  Here, we got a collision sensor-body.
			if is the first collision detect by this sensor
				then send message to sandbox */
		if (bodySensor.nCollided === 0) {
			// notify new collision
			var message = {
				id: bodySensor.getBodyName(),
				state: "begin"
			};
			sendMessage("sensor", message);
		}
		//increment the collision count
		bodySensor.addcollision();
	}
};
\end{lstlisting}

Como se puede ver en la linea 21, la comprobación acabará si el cuerpo percibido es una parte del coche, como una rueda o el propio cuerpo principal. La forma de comprobar si un cuerpo es parte del robot es con el nombre del cuerpo. Este se ha establecido en la creación de los cuerpos con la función \texttt{setName()} de la clase \texttt{Body}.

También, se puede ver como en las lineas 28 a 33 se notifica la colisión enviando un mensaje. En secciones posteriores se explicará el proceso de notificación y la comunicación del simulador con el resto de la aplicación.

\subsection{Detectando lineas}
\label{detectando-lineas}

Antes de poder hablar de como se detectan lineas, es necesario hablar de las propias lineas.

Una característica del simulador que estaba clara desde el comienzo del proyecto era la necesidad de que el robot pudiera seguir lineas. Para poder seguir lineas, es necesario poder calcular la distancia del robot a una linea. Esto implica el cálculo de la distancia de un punto a una linea. Pero, ¿qué forma tiene la linea?

Hay dos opciones para la forma de las lineas: líneas rectas o curvas. Las lineas rectas darían una forma muy simple al circuito y no se corresponden con los circuitos que podrían crearse en la realidad. Además, la programación del robot sigue-líneas sería muy simple para el niño (solo tendría que asegurarse de que cuando encuentra una linea, no se tuerce). Así que esto elimina la opción de usar rectas para modelar las líneas. 


\subsubsection{Curvas de Bezier}
\label{bezier}

Entonces, una curva. Existen principalmente dos tipos de curvas usadas en computación gráfica: curvas de Catmull-Rom y curvas de Bezier. 

Las curvas de Carmull-Rom\footnote{Para más información sobre las curvas de Catmull-Rom se puede consultar \cite{curves-catmull-rom-introduction} o \cite{catmull-rom-splines}.} se definen con una serie de puntos de control o \emph{splines} que definen la forma de la curva en base a la interpolación de los puntos que la forman. La curva pasará por todos los puntos que la forman y es posible añadir más puntos \emph{sobre la marcha} para alargar la curva. Un ejemplo de curva de Catmull-Rom se puede ver en la figura \ref{fig:curva-catmull}.


\begin{figure}[!ht]
	\begin{centering}
		\includegraphics[width=0.4\textwidth]{images/curva-catmull.png}
			\caption{Ejemplo de curva de Catmull-Rom con 4 puntos que definen su forma. Obtenido de \cite{curves-catmull-rom-introduction}.}
				\label{fig:curva-catmull}
	\end{centering}
\end{figure}


El otro tipo de curva son las curvas de Bezier\cite{bezier-info}. Las curvas de Bezier se definen por 2 puntos, el origen y el extremo de la curva, y por al menos un punto más de control. Las curvas de Bezier con solo un punto de control se denominan curvas cuadráticas. Si tiene 2 puntos de control, se denomina curva de Bezier cúbica. Un ejemplo de curvas de Bezier cuadrática y cúbica se puede ver en las figuras \ref{fig:bezier-2} y \ref{fig:bezier-3}, respectivamente.


\begin{figure}[!ht]
	\begin{adjustwidth}{\oddsidemargin-1in}{\rightmargin}
	%	\centering
			\begin{subfigure}{\paperwidth}
				\centering
				\includegraphics[scale=.5]{images/bezier-2.png}
	\caption{Ejemplo de curvas de Bezier cuadrática. Obtenido de \url{http://pomax.github.io/bezierjs}.}				
				\label{fig:bezier-2}
			\end{subfigure}
			\begin{subfigure}{\paperwidth}
				\centering
				\includegraphics[scale=.5]{images/bezier-3.png}
	\caption{Ejemplo de curvas de Bezier cúbica. Obtenido de \url{http://pomax.github.io/bezierjs}.}				
				\label{fig:bezier-3}
			\end{subfigure}
	\end{adjustwidth}
\end{figure}


Las curvas de bezier se definen en función de t, que se mueve en un intervalo de 0 a 1. Siendo \texttt{t=0} el inicio de la curva, \texttt{t=1} el final y \texttt{t=0.5} el punto intermedio. Una linea recta también puede ser representada mediante curvas de Bezier siempre que los puntos de control estén sobre la linea. No obstante, estas curvas tiene una limitación: no se puede representar un circunferencia con una (única) curva de Bezier. Esto es algo que no afecta a nuestro simulador.

Finalmente, para el modelado de lineas se ha decidido usar las curvas de Bezier, acompañado de la librería BezierJS\footnote{Página oficial del proyecto BezierJS (\url{http://pomax.github.io/bezierjs/}).} para Javascript. Esta librería ofrece una serie de funciones muy útiles para crear y manejar funciones. En el listado de código \ref{code:ejemplo-uso-bezier} se puede ver un ejemplo de las funciones más importantes de la librería. 

\begin{lstlisting}[language={Javascript},label={code:ejemplo-uso-bezier}, caption={Ejemplo de uso de las funciones de la librería BezierJS.}]
var curve = new Bezier (150,40 , 80,30 , 105,150);

var mid = curve.get(0.5);

var steps = 10;
var points = curve.getLUT(steps);
\end{lstlisting}

En la linea 1 del listado \ref{code:ejemplo-uso-bezier} se crea una curva cuadrática con los puntos \texttt{(150, 40)}, \texttt{(80, 30)} y \texttt{(105, 150)}. Concretamente, esta curva toma la forma de la curva de la figura \ref{fig:bezier-2}. El segundo punto es el punto de control. Una curva cubica se definiría de forma similar, pero pasando como argumento un punto de control más. 

En la linea 3 del listado \ref{code:ejemplo-uso-bezier} se obtiene el punto que está justo en la mitad de la curva. La función \texttt{getLUT()} devuelve un array de puntos equidistantes entre ellos dentro de la curva. El número de puntos es el valor de \texttt{steps} más 1.

La función \texttt{getLUT()} de la librería BezierJS será la clave para la detección de lineas en el simulador.


\subsubsection{Detectando curvas de Bezier}

Ahora que ya se ha aclarado que se usarán curvas de Bezier para representar las lineas en el simulador, solo queda saber la distancia de un punto (el sensor) al punto más cercano de la curva de Bezier. Este problema consiste en encontrar la proyección de un punto sobre una curva. Dicho problema ya ha sido estudiado anteriormente. Por ejemplo J. Ros en \cite{projection-point-bezier} estudia de manera matemática como resolver este problema. 

Teniendo esto en cuenta, ésta fue la primera aproximación al problema que se realizó. Los resultados no fueron buenos: el punto en la curva no era exacto y con un coste computacional alto.

En el segundo intento de resolución, se utilizaba la función \texttt{getLUT()} de BezierJS para partir la curva en muchas lineas rectas y crear un cuerpo en Box2D con muchas \texttt{fixtures}\footnote{Para crear la forma de linea recta en Box2D se utilizaba la clase \texttt{b2PolygonShape} estableciendo la forma con la función \texttt{SetAsEdge()} que recibe dos puntos y crea una linea entre ellos.}. De esta manera se conseguía formar una curva a partir de muchas lineas rectas. La detección de curvas, entonces, se realizaba igual que para los obstáculos (sección \ref{detectando-colisiones}).

Esto solucionaba el problema, pero la curva tenía una apariencia muy fina y se obtenía un coste alto al mantener una cantidad tan grande de cuerpos pequeños. Aunque se simplificara la curva con un valor de \texttt{step} suficientemente pequeño en la función \texttt{getLUT()}, no se solucionaba el problema de la linea fina.

La tercera aproximación al problema dio resultado. Era volver a proyectar el punto (sensor) sobre la curva, pero aproximando los puntos de ésta con la función \texttt{getLUT()}. De esta manera, se obtenía una cantidad razonable de puntos en la curva y se calculaba la distancia del sensor a cada uno de estos, resultando el problema en el cálculo de distancia entre dos puntos. Algo computacionalmente menos costoso que calcular la proyección de un punto sobre una curva. 

En el listado de código \ref{code:deteccion-bezier} se puede ver el código que detecta y notifica una \emph{colisión} con una linea. 

\begin{lstlisting}[language={Javascript},label={code:deteccion-bezier}, caption={Función que detecta lineas (curvas de Bezier).}]
function detectLineCollition(sensor) {
	var lines = Simulator.World.lines;
	var anysensed = false;

	// (...)

	var minDistance = Simulator.World.getDistanceCollitionLine();

	lines.forEach(function(curve) {
		var p = pointInBezier(curve, SensorPosition);
		// if any sensor collided, notify!
		var dist = distance(p, position);
		if (dist <= minDistance) {
			//notify the collision
			var message = {
				id: sensor.name,
				state: "begin"
			};
			sendMessage("sensor", message);
			anysensed = true;
			return;
		}

	});
	//if it detects no collitions, notify end collision
	if (!anysensed) {
		var message = {
			id: sensor.name,
			state: "end"
		};
		sendMessage("sensor", message);
	}
}
\end{lstlisting}

El valor de distancia mínima (variable \texttt{minDistance}) se define con el grosor de la linea más el radio del sensor.

La diferencia de esta última solución a la anterior es que en ningún momento se está creando la curva como objeto en Box2D. Por tanto, se ha modificado el prototipo de \texttt{World} para que almacene las lineas (variable \texttt{lines}). No obstante, siguen sin ser representadas con un objeto \texttt{Body} para ahorra coste y para facilitar el poder pintar distinto grosor de linea según convenga (por ejemplo, si se hace zoom en el circuito).

Con respecto al dibujo de las lineas, se explicará más adelante en la sección \ref{animando-robode}.


\subsection{Animando a Robode}
\label{animando-robode}



Para entender como se ha realizado la animación del simulador, primero es necesario conocer algunos conceptos de Javascript.

Javascript proporciona una serie de funciones para gestionar timers en la ejecución de un programa. Estos son:

\begin{itemize}
	\item \texttt{setTimeout(function, delay)}: Ejecuta la función \texttt{function} después de un tiempo especificado por \texttt{delay}. Devuelve un \texttt{id} que identifica al timer.
	\item \texttt{setInterval(function, delay)}: Ejecuta la función \texttt{function} de manera periódicamente cada vez que se cumple el \texttt{delay}. Devuelve un \texttt{id} que identifica al timer.
	\item \texttt{clearTimeout(id)} y \texttt{clearInterval(id)}: funciones que eliminan el timer asociado a ese \texttt{id}.
\end{itemize}

El uso normal que se haría en la aplicación (el simulador junto a Descubre) será ejecutar la función \texttt{setInterval(function, delay)} con un \texttt{delay} igual al número de veces por segundo que queremos que se actualice el simulador. Cada vez se ejecutará la función \texttt{function} (que normalmente contendrá \texttt{World.Step()} y la actualización de los gráficos).

Por tanto, cada vez que se produzca un evento (por ejemplo, una interrupción de teclado o ratón), la ejecución de Javascript tratará dichos eventos. 

No obstante, Javascript tiene una limitación: implementa un sistema \emph{monohilo}. Esto implica que si hay una función que aún no ha terminado de ejecutarse cuando ocurre un timer o un evento, estos se verán retrasados hasta que dicha función acabe\footnote{Para mas información al respecto, se puede consultar \cite{js-timers-works}, \cite{event-loop-js} y \cite{resig2013secrets}.}.

{\color{red} ¿¿¿¿¿LE HAGO SUFICIENTE REFERENCIA CON EL PIE DE PÁGINA Y LAS CITAS????}

Si esta situación se diera en el simulador, se detendría toda la aplicación provocando principalmente que Robode deje de moverse (su estado con respecto al mundo no se actualizaría) y que no se pueda escribir en el editor de código (los eventos de teclado y ratón se tratarían tarde).

Y precisamente este es el efecto que produciría la función \texttt{wait(n\_miliseg)} de la API del simulador, descrita en la sección \ref{sec:modificacion-ijava}. Obviamente, este efecto va en contra de correcto funcionamiento que debe tener el simulador y la aplicación por completo.

Para solventar este problema, existen los Web Workers\cite{web-worker-mdn} en Javascript. Básicamente, un Web Worker (o worker para acortar) permite ejecutar tareas en segundo plano separado del hilo principal. Es decir, se consigue un sistema \emph{multihilo} en Javascript. La comunicación del worker con el resto de elementos se hace mediante mensajes, como los que se han visto anteriormente en los códigos \ref{code:deteccion-bezier} o \ref{code:begin-contact}.

{\color{red}
Aún así, los Workers tienen sus limitaciones. La más importante es que no se puede interactuar con el DOM\footnote{El DOM (Document Object Model o Modelo de Objetos del Documento en español) es un API de programación para documentos de HTML. Parte fundamental de HTML y que contiene toda la información relacionada a la página web} de HTML. Esto hace que no se pueda dibujar en el \emph{canvas}. 

Entonces, la solución radica en convertir el Sandbox en un Web Worker y que sea éste el que controle la ejecución del simulador mediante mensajes. De esta manera se consigue paralelizar la aplicación y que la ejecución de la función \texttt{wait()} esté en un hilo independiente del principal. 
}

En el hilo principal se ejecutará la función \texttt{setInterval()} con un valor de \texttt{delay} equivalente a 60 FPS (frames por segundo). Cada vez que se ejecute dicha función, se actualizarán las fuerzas del mundo, el movimiento del robot y se dibujará por pantalla el estado actual del mundo. En el código \ref{code:interval-function} se muestra la ejecución de la función \texttt{setInterval()}.

\begin{lstlisting}[language={Javascript},label={code:interval-function}, caption={Función \texttt{setInterval()} que se ejecutara 60 veces por segundo.}]
idInterval = window.setInterval(function() {
    Simulator.World.Step(
        1 / 60, //frame-rate
        10, //velocity iterations
        10 //position iterations
    );

    // Simulator.World.drawLines();
    Simulator.World.DrawDebugData();
    Simulator.World.ClearForces();

    updateMovement();

}, 1000 / 60);
\end{lstlisting}


\subsubsection{Dibujando a robode}

Una vez que se ha aclarado como es la actualización del mundo, queda especificar como se dibuja el mismo.

Box2D provee de un elemento para dibujar 



%\subsubsection{Multihilo y esas cosas}
Aquí se habla de como se anima y que tiene que decir JS y su sistema monohilo al respecto. También temas de zoom y scroll y relación de tamaño del robot con la escala. Dibujo de las lineas



\subsection{Construcción de circuitos}
\label{sec:construccion-circuitos}


{\color{green} ===POR AQUI===}.


%El entorno o circuito por el que se moverá el robot tiene los siguientes elementos: (a) obstáculos, con los que podrá chocar y que se desplazaran por la colisión; (b) fronteras, que no podrán ser desplazadas o atravesadas por el robot y (c) lineas, que no producirán una colisión pero que podrán ser detectadas por el robot. 

